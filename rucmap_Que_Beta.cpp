#include<iostream>
#include<cstdio>
using namespace std;
#define MaxSize 235

int maze[14][28]=                     //迷宫
    {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,1,
     1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,
     1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,
     1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,
     1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,0,1,1,0,1,1,1,1,0,1,
     1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,0,1,
     1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
     1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
     1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,
     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
struct
{
	int i,j,dir;
	int pre;
 }Q[MaxSize];//直接用数组方便一点。要不还得自己做顺序表。：（

int front=-1,rear=-1;//头尾指针。

void print(int front)
{
	int rout[14][28]=
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
     1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,1,
     1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,
     1,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,
     1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,
     1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,0,1,1,0,1,1,1,1,0,1,
     1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,0,1,
     1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
     1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
     1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,
     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,
     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
	int k=front,j;
	cout<<'\n';
	do
	{
		rout[Q[k].i][Q[k].j]=Q[k].dir;
		k=Q[k].pre;

	}while(k!=0);
	rout[Q[0].i][Q[0].j]=6;
	rout[Q[front].i][Q[front].j]=7;
	cout<<"迷宫路径如下："<<'\n';

	    for(int i=0;i<14;i++)          //迷宫图形化输出
    {
        for(int j=0;j<28;j++)
        {
            if(rout[i][j]==1)
                {cout<<"■";}
            if(rout[i][j]==0)
                {cout<<"□";}
			if(rout[i][j]==2)
                {cout<<"→";}
            if(rout[i][j]==3)
                {cout<<"↓";}
            if(rout[i][j]==4)
                {cout<<"←";}
            if(rout[i][j]==5)
                {cout<<"↑";}
			if(rout[i][j]==6)
                {cout<<"☆";}
			if(rout[i][j]==7)
                {cout<<"★";}
        }
		cout<<'\n';
    }
}
int MazePath(int k,int l,int m,int n)
{
	int i,j,find=0,di;
	rear++;
	Q[rear].i=k;
	Q[rear].j=l;
	Q[rear].pre=-1;
	maze[k][l]=-1;//入队并将出口标记,初始化
	while(front<=rear&&!find)
	{
		front++;
		i=Q[front].i;j=Q[front].j;
		if(i==m&&j==n)
		{
			find=1;
			print(front);
			return 1;
		 }
		for(di=2;di<6;di++)
		{
			switch(di)
			{
			case 2:
				i=Q[front].i;j=Q[front].j+1;break;//向右
			case 3:
				i=Q[front].i+1;j=Q[front].j;break;//向下
			case 4:
				i=Q[front].i;j=Q[front].j-1;break;//向左
			case 5:
				i=Q[front].i-1;j=Q[front].j;break;//向上
			 }
			if(maze[i][j]==0)//如果道路可通，则入队
			{
				rear++;
				Q[rear].i=i;Q[rear].j=j;Q[rear].dir=di;//尾指针向后移
				Q[rear].pre=front;//指向路径中上一个方块的路标
				maze[i][j]=-1;//将走过的地方进行标记
			 }
		 }
	}
	return 0;
}

int main()
{
	for(int i=0;i<14;i++)          //迷宫图形化输出
    {
        for(int j=0;j<28;j++)
        {
            if(maze[i][j]==1)
                printf("■");
            else cout<<"□";
        }
        cout<<endl;
    }
	int a,b,c,d;
	cout<<"入口坐标：";
	cin>>a>>b;
	cout<<"出口坐标：";
	cin>>c>>d;
	MazePath(a,b,c,d);
	return 0;
}
